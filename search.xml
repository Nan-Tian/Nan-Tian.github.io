<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BSGS 与 exBSGS</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E4%B8%8EexBSGS/</url>
    <content><![CDATA[<h1 id="BSGS与exBSGS"><a href="#BSGS与exBSGS" class="headerlink" title="BSGS与exBSGS"></a>BSGS与exBSGS</h1><blockquote>
<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><p>BSGS(baby-step giant-step),即大步跳小步算法，该算法可以在$O(\sqrt n)$时间内求解：</p>
<p>​                                                                        <font size=3 color=#FF7F50>$a^x\equiv b\pmod p$</font></p>
<p>注：其中$gcd(a,p)=1,0\le x \lt p$</p>
<h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><p>设$m=\sqrt p$，</p>
<p>令$x=im-j$,其中$0\le i,j \le m$,则有<font color=#FF4F00>$a^{im-j}\equiv b \pmod p$</font>,变换后可得<font color=#FF4F00>$a^{im}\equiv ba^j\pmod p$</font></p>
<p>之后左右枚举$j$存到$hash/map$里，然后枚举$i$，计算$a^{im}$寻找是否有与之相等的$ba^j$从而得到所有的$x$,$x=im-j$.</p>
<p>用$map$多一个$log$的复杂度，总复杂度为$O(log(p)\sqrt p)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">fast_mul</span><span class="params">(ll a, ll b, ll p)</span><span class="comment">//龟速乘防爆long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      ret += a;</span><br><span class="line">      <span class="keyword">if</span> (ret &gt; p)</span><br><span class="line">          ret -= p;</span><br><span class="line">  &#125;</span><br><span class="line">  a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; p)</span><br><span class="line">      a -= p;</span><br><span class="line">  b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; hs;</span><br><span class="line">ll tmp = <span class="number">1</span>, k = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(m));</span><br><span class="line"><span class="keyword">if</span>(!(a%m)&amp;&amp;b) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//被坑的点（如果a%m为0且b不为0，那么无论指数为多大都不成立）</span></span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//被坑的点</span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  tmp = fast_mul(tmp, a, m);</span><br><span class="line">  <span class="keyword">if</span> (tmp == b)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  hs[fast_mul(tmp, b, m)] = i;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  ans = fast_mul(ans, tmp, m);</span><br><span class="line">  <span class="keyword">if</span> (hs.find(ans) != hs.end())</span><br><span class="line">      <span class="keyword">return</span> i * k - hs[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h2><p>现在求解（$gcd(a,p)\not=1$）的情况：</p>
<p>​                                                                        <font size=3 color=#FF7F50>$a^x\equiv b\pmod p$</font></p>
<p>注：其中$gcd(a,p)$不一定等于1</p>
<p>我们先设$d_1=gcd(a,p)$,如果$d_1\not\mid b$ 则原方程无解，否则方程两边同时除以$d_1$得到    </p>
<p>​                                                                <font size=3 color=#FF7F50>$\dfrac {a}{d_1}a^{x-1}\equiv \dfrac {b}{d_1} \left(\bmod\frac {p}{d_1}\right)$</font></p>
<p>如果$a$和$\dfrac {p}{d_1}$仍不互质就再除,同理继续设$d_2$一直到$gcd(a,\frac{p}{d_1d_2\cdots d_n})$，记$D=\prod\limits _{i=1}^k d_i$，于是方程变成了这样：</p>
<p>​                                                                <font size=3 color=#FF7F50>$\dfrac {a^k}{D}\cdot a^{x-k}\equiv \dfrac {b}{D} \left(\bmod \frac{p}{D}\right)$</font></p>
<p>由于$gcd(a,\frac{p}{D})=1$，可以推出$gcd=(a^{x-k},\frac {p}{D})=1$,这样就变成了普通的BSGS问题了，只要求出$x-k$再加上$k$即为所求解了</p>
<p>注：不排除解$x$小于等于$k$的情况，因此我们可以先$O(k)$枚举一下，直接验证    <font color=#FF7F50>$a^i\equiv b\pmod p$</font>即可避免这种情况</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function">ll <span class="title">fast_mul</span><span class="params">(ll a, ll b, ll p)</span><span class="comment">//龟速乘防爆long long</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&gt;ll ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&gt;&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   ret += a;</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; p)</span><br><span class="line">       ret -= p;</span><br><span class="line">&gt;&#125;</span><br><span class="line">a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (a &gt; p)</span><br><span class="line">   a -= p;</span><br><span class="line">&gt;b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">exgcd(b, a % b, x, y);</span><br><span class="line">ll k = x;</span><br><span class="line">x = y;</span><br><span class="line">y = k - (a / b) * y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll b)</span><span class="comment">//求逆元</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   ll x, y;</span><br><span class="line">  exgcd(a, b, x, y);</span><br><span class="line">  <span class="keyword">return</span> (x % b + b) % b;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; hs;</span><br><span class="line">ll tmp = <span class="number">1</span>, k = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(m));</span><br><span class="line"><span class="keyword">if</span>(!(a%m)&amp;&amp;b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">&#123;</span><br><span class="line">tmp = fast_mul(tmp, a, m);</span><br><span class="line"><span class="keyword">if</span> (tmp == b)</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">hs[fast_mul(tmp, b, m)] = i;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">ans = fast_mul(ans, tmp, m);</span><br><span class="line"><span class="keyword">if</span> (hs.find(ans) != hs.end())</span><br><span class="line">   <span class="keyword">return</span> i * k - hs[ans];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exBSGS</span><span class="params">(ll a, ll b, ll p)</span><span class="comment">//先让P/D与a^&#123;x-k&#125;互质</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll g = gcd(a, p), tmp = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (g != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b % g)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">k++;</span><br><span class="line">b /= g, p /= g, tmp = tmp * (a / g) % p;</span><br><span class="line"><span class="keyword">if</span> (tmp == b)</span><br><span class="line">   <span class="keyword">return</span> k;</span><br><span class="line">g = gcd(a, p);</span><br><span class="line">&#125;</span><br><span class="line">  ll ans = BSGS(a, b * inv(tmp, p) % p, p);</span><br><span class="line">  <span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">return</span> ans + k;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  ll a, p, b;</span><br><span class="line">   <span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; p &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> ((!a) &amp;&amp; (!p) &amp;&amp; (!b))</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">a %= p, b %= p;</span><br><span class="line">ll ans = exBSGS(a, b, p);</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>  <font size=7> <a href="#BSGS%E4%B8%8EexBSGS">返回首页</a></font></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CRT 与 exCRT</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/CRT%E4%B8%8EexCRT/</url>
    <content><![CDATA[<h1 id="CRT与exCRT"><a href="#CRT与exCRT" class="headerlink" title="CRT与exCRT"></a>CRT与exCRT</h1><blockquote>
<h2 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a><font color=00BFF>CRT</font></h2><p><del>在百度百科与博客的食 用下终于把证明看懂了</del></p>
<h3 id="引理："><a href="#引理：" class="headerlink" title="引理："></a>引理：</h3><p>引理1：$a\equiv c\pmod b$ 等价于$(a+kb)\equiv c\pmod b$</p>
<p>引理2：若有$a\equiv c\pmod b，$那么$ka\equiv kc\pmod b$</p>
<p>GRT给出了以下的一元线性同余方程组<br>$$<br>\begin{aligned}<br>(S): \begin{cases}<br>x &amp;\equiv a_1\pmod{m_1}<br>\<br>x &amp;\equiv a_2 \pmod{m_2}<br>\<br>&amp;\vdots<br>\<br>x&amp;\equiv a_n\pmod{m_n}<br>\end{cases}<br>\end{aligned}<br>$$</p>
<h3 id="CRT有解条件："><a href="#CRT有解条件：" class="headerlink" title="CRT有解条件："></a>CRT有解条件：</h3><p>假设整数$m_1,m_2,\cdots,m_n$两两互质，则对任意整数$a_1,a_2,\cdots,a_n$方程组（S）有解</p>
<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><p>1.设$M=\prod\limits_{i=1}^n m_i,$</p>
<p>2.设$M_i=\dfrac{M}{m_i},t_i$为$M_i$的逆元（即$t_iM_i\equiv 1\pmod {m_i}$）</p>
<p>3.计算$C_i=M_it_i$(<strong>不对$m_i$取模</strong>)</p>
<p>4.方程的通解为$x=kM+\sum\limits_{i=1}^n a_ic_i$</p>
<p>5.在模$M$意义下方程有唯一解$x=\sum\limits_{i=1}^n a_ic_i \pmod M$($x$即为所有方程余数的和模所有模数积的值)</p>
<h3 id="算法的证明："><a href="#算法的证明：" class="headerlink" title="算法的证明："></a>算法的证明：</h3><p>文字和公式并用，可能有点乱<del>先文字口胡一下</del></p>
<p>假设$(1)x\equiv 2\pmod 3,(2)x\equiv 3\pmod 5,(3)x\equiv 7 \mod 2$</p>
<p>假设$n_1$是满足（1）式的一个数，$n_2$是满足(2)式的一个数，$n_3$是满足(3)式的一个数</p>
<p><font size=3>根据引理1可知，若$n_2$是$3$的倍数，则$n_1+n_2$也是$3$的倍数，同理可得$n_1+n_2+n_3$也是$3$的倍数,再从$n_2$，$n_3$的角度出发，我们可推导出以下三点：</font></p>
<p>1.为使$n_1+n_2+n_3$的和满足除以$3$余$2$，$n_2$和$n_3$必须是$3$的倍数。</p>
<p>2.为使$n_1+n_2+n_3$的和满足除以$5$余$3$，$n_1$和$n_3$必须是$5$的倍数。</p>
<p>3.为使$n_1+n_2+n_3$的和满足除以$7$余$2$，$n_1$和$n_2$必须是$7$的倍数。</p>
<p><font size=3>因此，为使$n_1+n_2+n_3$的和作为“孙子问题”的一个最终解，需满足：</font></p>
<p>1.$n_1$除以$3$余$2$，且是$5$和$7$的公倍数。</p>
<p>2.$n_2$除以$5$余$3$，且是$3$和$7$的公倍数。</p>
<p>3.$n_3$除以$7$余$2$，且是$3$和$5$的公倍数。</p>
<p><font size=3>所以，孙子问题解法的本质是从$5$和$7$的公倍数中找一个除以$3$余$2$的数$n_1$，从$3$和$7$的公倍数中找一个除以$5$余$3$的数$n_2$，从$3$和$5$的公倍数中找一个除以$7$余$2$的数$n_3$，再将三个数相加得到解。在求$n_1，n_2，n_3$时又用了一个小技巧，以$n_1$为例，并非从$5$和$7$的公倍数中直接找一个除以$3$余$2$的数，而是先找一个除以$3$余$1$的数，再乘以$2$。也就是<strong>求出$5$和$7$的公倍数模$3$下的逆元，再用逆元去乘余数</strong>。(引理2可以证明)</font></p>
<p><font size=5>由此假设</font></p>
<p><font size=4>设$M=m_1\times m_2\times m_3\cdots\times m_n=\prod\limits_{i=1}^n m_i$ </font></p>
<p><font size=4>并设$M_i=\dfrac {M}{m_i}$($M_i$即为除了$m_i$以外其他互质数的乘积(最小公倍数))</font></p>
<p><font size=4>设$t_i$为$M_i$的逆元（即$t_iM_i\equiv 1\pmod {m_i}$）</font></p>
<p><font size=2 color=#FF7F>$a_it_iM_i$(即相当于逆元乘余数再乘最小公倍数得出$n_i$)</font></p>
<p>因此$x$的通解为:</p>
<p>$x=n_1+n_2+\cdots+n_n=a_1C_1+a_2C_2+\cdots+a_nC_n=kM+\sum\limits_{i=1}^{n} a_iC_i$</font></p>
<p><font size=4>(这里的$x$通解一定为$M$的$k$倍加上一个小于$M$的余数）</font><br><font size=4>最后对M取模可得小于M的唯一解$x=\sum\limits_{i=1}^{n}a_ic_i\pmod M$</font></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//&amp;是求逆元</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (!b)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;exgcd(b, a % b);</span><br><span class="line">&gt;<span class="keyword">int</span> k;</span><br><span class="line">&gt;k = x;</span><br><span class="line">&gt;x = y;</span><br><span class="line">&gt;y = k - (a / b) * y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">  sum *= a[i];<span class="comment">//求M</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">ll x,y;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  ll m = sum / a[i];<span class="comment">//求m_i</span></span><br><span class="line">  exgcd(m, a[i]);</span><br><span class="line">  ll t = (x % a[i] + a[i]) % a[i];<span class="comment">//求逆元</span></span><br><span class="line">  ans = (ans + b[i] * m * t) % sum;<span class="comment">//求和</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="exCRT"><a href="#exCRT" class="headerlink" title=" exCRT"></a><font color=00BFF> exCRT</font></h2><p><font size=3>exCRT是为了解决模数不互质的情况<del>深受毒瘤出题人喜爱</del></font></p>
<p><font size=3>自我感觉和CRT差别很大</font><br>       <font size=3>我们先假设两个式子：</font></p>
<p>​                                                                <font color=#FF4500>$x=a_1+m_1x_1$</font></p>
<p>​                                                                <font color=#FF4500>$x=a_2+m_2x_2$</font></p>
<p>那么得到：</p>
<p>​                                <font color=#FF4500>$a_1+m_1x_1=a_2+m_2x_2\Rightarrow m_1x_1+m_2x_2=a_1-a_2$($m$为整数)</font></p>
<p>我们需要求出一个最小正整数解$x$使其满足：</p>
<p>​                                                        <font color=#FF4500>$x=a_1+m_1x_1=a_2+m_2x_2$</font></p>
<p>　那么$x_1$和$x_2$就要尽可能的小，于是我们用扩展欧几里得算法求出$x_1$的最小正整数解，将它代回$a_1+m_1x_1$，得到$x$的一个特解$x’$，当然也是最小正整数解。</p>
<p>所以$x$的通解一定是$x’$加上$lcm(m_1,m_2)∗k$，这样才能保证$x$模$m_1$和$m_2$的余数是$a_1$和$a_2$。由此，我们把这个$x’$当做新的方程的余数，把$lcm(m_1,m_2)$当做新的方程的模数。（这一段是<strong>关键</strong>）</p>
<p><font size=4>合并完成：</font></p>
<p>​                                                        <font color=#FF4500>$x\equiv x’ \pmod {lcm\left(m_1,m_2\right)}$</font></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">inline</span> ll <span class="title">fast_mul</span><span class="params">(ll a, ll b, ll p)</span><span class="comment">//龟速乘，防爆long long</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;ll t = <span class="number">0</span>;</span><br><span class="line">&gt;a %= p;</span><br><span class="line">&gt;<span class="keyword">while</span> (b)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">      t = (t + a) % p;</span><br><span class="line">  b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  a = (a + a) % p;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> t;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (!b)</span><br><span class="line">&gt;&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;exgcd(b, a % b, x, y);</span><br><span class="line">&gt;ll k = x;</span><br><span class="line">&gt;x = y;</span><br><span class="line">&gt;y = k - (a / b) * y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;ll n, a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line">&gt;<span class="function">ll <span class="title">exChina</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;ll A = a[<span class="number">1</span>], B = b[<span class="number">1</span>], x, y;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//不断合并方程</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">  ll d = gcd(A, a[i]);</span><br><span class="line">  <span class="keyword">if</span> ((b[i] - B) % d)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  exgcd(A, a[i], x, y);</span><br><span class="line">  ll mod = a[i] / d;</span><br><span class="line">  x = fast_mul(x % mod + mod, (((b[i] - B) / d) % mod) + mod, mod);</span><br><span class="line">  mod = lcm(A, a[i]);</span><br><span class="line">  B = (fast_mul(x, A, mod) + B) % mod;</span><br><span class="line">  A = mod;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> B;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>欧拉函数，即$\varphi(n)$，表示的是小于等于$n$和$n$互质的数的个数，即$\varphi(n) = \sum_\limits{i=1}^{n} [gcd(i,j)=1]$，比如$\varphi(2)=1$。当$N$是质数的时候，显然有$\varphi(N)=N-1$。</p>
<p>利用算术基本性质我们可以将正整数$n$分解为$N=\prod\limits_{i=1}^{n} p_i^{k_i}$其中$p_i$为质数，那么$\varphi(N)=N\prod\limits _{i=1}^n \dfrac{p_i-1}{p_i} $</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>$n=\sum\limits_{d \mid n} \varphi(d)$</p>
<p>证明：</p>
<p>​    如果 $gcd(k,n)=d$ ，那么$gcd(\frac{k}{d},\frac{n}{d}) = 1$ </p>
<p>​        设 $f(x)$ 表示 $gcd(k,n)=x(gcd(\frac{k}{x},\frac{n}{x})=1)$的数的个数，那么 $n=\sum\limits_{i=1}^n f(i)$ ，又因为 $f(x)=\varphi(\frac{n}{x})$ ，因此   $n=\sum\limits_{d \mid n} \varphi(\frac{n}{d})$  ，因为约数对称性所以 $n=\sum\limits_{d \mid n} \varphi(d)$</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><h3 id="引理1："><a href="#引理1：" class="headerlink" title="引理1："></a>引理1：</h3><p>​                                                设$x=p^k$($p$为质数),那么$\varphi(x)=p^{k-1}\times (p-1)$</p>
<p>证明：设$y(y\bmod p\not=0),gcd(x,y)=1$,我们可以将$x$分成长度为$p$的$p^{k-1}$段，每一段都有$p-1$个数与$x$互质，</p>
<p>​            因此与$x$互质的数的个数为$p^{k-1}\times (p-1)$</p>
<h3 id="欧拉函数证明："><a href="#欧拉函数证明：" class="headerlink" title="欧拉函数证明："></a>欧拉函数证明：</h3><p>$$<br>\because N=\prod_{i=1}^n p_i^{k_i}<br>\<br>\begin{aligned}<br>\therefore \varphi(x)&amp;=\prod_{i=1}^n \varphi(p_i^{k_i})<br>\<br>&amp;=\prod_{i=1}^n (p_i-1)\times p_i^{k_i-1}<br>\<br>&amp;=\prod_{i=1}^n(\dfrac{p_i-1}{p_i})p^{k_i}<br>\<br>&amp;=\prod_{i=1}^n (1-\dfrac{1}{p_i})p^{k_i}<br>\<br>&amp;=x\prod_{i=1}^n (1-\dfrac{1}{p_i})<br>\end{aligned}<br>$$</p>
<p>若$N=p^k$($p$为质数)，则$\varphi(N)=p^k-p^{k-1}=(p-1)p^{k-1}$(根据定义)</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="质因数分解求"><a href="#质因数分解求" class="headerlink" title="质因数分解求"></a>质因数分解求</h3><p>适合求单点$O(\sqrt n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;ll ans=n;</span><br><span class="line">&gt;<span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">&gt;<span class="keyword">if</span>(!(n%i))</span><br><span class="line">&gt;&#123;</span><br><span class="line"> ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line"> <span class="keyword">while</span>(!(n%i))</span><br><span class="line">     n/=i;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);<span class="comment">//防止有没筛完的</span></span><br><span class="line">&gt;<span class="keyword">return</span> ans;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性筛欧拉函数"><a href="#线性筛欧拉函数" class="headerlink" title="线性筛欧拉函数"></a>线性筛欧拉函数</h3><p>适合求$1\sim n(O(n))$</p>
<p>设$p$是$n$最小质因子,$N’=\dfrac {N}{p}$那么线性筛的过程中$n$ 通过$N’\times p$筛掉。</p>
<p>观察线性筛的过程，我们还需要处理两个部分，下面对$N’\bmod p$ 分情况讨论。</p>
<p>(1)如果$N’\bmod p=0$，那么 $N’$包含了$N$的所有质因子。<br>$$<br>\begin{aligned}<br>\varphi(N)&amp;=N\times \prod_{i=1}^n \dfrac{p_i-1}{p_i}<br>\<br>&amp;=p\times N’\times \prod_{i=1}^{n}\dfrac{p_i-1}{p_i}<br>\<br>&amp;=p\times \varphi(N’)<br>\end{aligned}<br>$$</p>
<p>(2)如果$N’\bmod p\not=0$，这时$N’$和$p$是互质的根据欧拉函数性质，我们有：<br>$$<br>\begin{aligned}<br>\varphi(N)&amp;=\varphi(p)\times \varphi(N’)<br>\<br>&amp;=(p-1)\times \varphi(N’)<br>\end{aligned}<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">int</span> phi[n];</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">if</span> (!phi[i])<span class="comment">//外层枚举n的质因子</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!phi[j])<span class="comment">//如果没被筛过就初始化为本身（相当于欧拉函数质因子分解求法）</span></span><br><span class="line">              phi[j] = j;</span><br><span class="line">          phi[j] = phi[j] / i * (i - <span class="number">1</span>);<span class="comment">//内层求每个数的欧拉函数(分开求得，比如15是先筛3再筛5)</span></span><br><span class="line">      &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数学学习笔记</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="数学学习笔记"><a href="#数学学习笔记" class="headerlink" title="数学学习笔记"></a>数学学习笔记</h1><blockquote>
<h2 id="一、初等数论"><a href="#一、初等数论" class="headerlink" title="一、初等数论"></a>一、<a href="#%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA">初等数论</a></h2><h2 id="二、期望"><a href="#二、期望" class="headerlink" title="二、期望"></a>二、<a href="#%E6%9C%9F%E6%9C%9B">期望</a></h2><h3 id="一、-初等数论"><a href="#一、-初等数论" class="headerlink" title="一、 初等数论"></a>一、<a id="初等数论"> <a href="#%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">初等数论</a></a></h3><h4 id="1-算术基本定理"><a href="#1-算术基本定理" class="headerlink" title="1.  算术基本定理"></a>1.  算术基本定理</h4><h5 id="概念-：任意一个正整数-N-gt-1-可分为有限个质数的乘积。"><a href="#概念-：任意一个正整数-N-gt-1-可分为有限个质数的乘积。" class="headerlink" title="概念 ：任意一个正整数$N$ &gt;1,可分为有限个质数的乘积。"></a>概念 ：任意一个正整数$N$ &gt;1,可分为有限个质数的乘积。</h5><h5 id="数学表示："><a href="#数学表示：" class="headerlink" title="数学表示："></a>数学表示：</h5><p>$$<br>N=2^{a_1}\times3^{a_2}\times5^{a_3}\times\cdots=\prod_{k=1}^\infty p_k^{a_k}<br>$$<br>其中 $a_1,a_2\cdots\in N$，我们称这个分解为 $N$的标准分解。</p>
<h4 id="2-素数无限定理"><a href="#2-素数无限定理" class="headerlink" title="2.素数无限定理"></a>2.素数无限定理</h4><h5 id="概念：正整数中有无限个素数。"><a href="#概念：正整数中有无限个素数。" class="headerlink" title="概念：正整数中有无限个素数。"></a>概念：正整数中有无限个素数。</h5><h5 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h5><h6 id="反证法："><a href="#反证法：" class="headerlink" title="反证法："></a>反证法：</h6><p>​                        假设有有限个素数,共为n个素数，设S<br>$$<br>S=1+\prod_{i=1}^n p_i<br>$$<br>​                        若N为素数，则显然不成立。</p>
<p>​                        若N为合数，$p_1\times p_2\times \cdots\times p_n  与S互质\left(gcd\left(S,S-1\right)=1,因此S不能被已知任意素数整除\right)$，与算术基本定理相矛盾，不成立。</p>
<h4 id="3-约数个数定理"><a href="#3-约数个数定理" class="headerlink" title="3.约数个数定理"></a>3.约数个数定理</h4><p>$$<br>ans=\prod_{i=1}^n (a_i+1)  \left( a_i为N标准分解后素数的指数\right)<br>$$</p>
<p>$$<br>简单证明正确性：N=2^{a_1}\times3^{a_2}\times5^{a_3}\times\cdots=\prod_{k=1}^\infty p_k^{a_k}<br>\<br>{p_1}^{a_1}的约数有{p_1}^0,{p_1}^1\cdots,{p_1}^{a_1}共有\left(a_1+1\right)个,p_2,p_3\cdots,p_n与此相同<br>\<br>最后根据乘法定理：N的约数个数即为\left(a_1+1\right)\times \left(a_2+1\right)\times\cdots\times \left(a_n+1\right)<br>$$</p>
<p>​                    </p>
<h4 id="4-约数和定理"><a href="#4-约数和定理" class="headerlink" title="4.约数和定理"></a>4.约数和定理</h4><p>$$<br>ans=\prod_{i=1}^n\sum_{j=0}^{a_i} p_i^j<br>$$</p>
<h4 id="5-GCD与LCM"><a href="#5-GCD与LCM" class="headerlink" title="5.GCD与LCM"></a>5.GCD与LCM</h4><h5 id="GCD与LCM集合含义："><a href="#GCD与LCM集合含义：" class="headerlink" title="GCD与LCM集合含义："></a>GCD与LCM集合含义：</h5><p>$$<br>gcd\left(a,b\right)=\prod_{i=1}^n {p_i}^{min\left(a_i,b_i\right)}<br>\<br>lcm\left(a,b\right)=\prod_{i=1}^n {p_i}^{max\left(a_i,b_i\right)}<br>$$</p>
<h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><p>$\left(1\right)GCD\left(a,b\right)=1$,那么a$,$b互质</p>
<p>$\left(2\right)gcd\left(2a,a\right)=gcd\left(a,a\right)=gcd\left(a,0\right)=a$</p>
<p>$\left(3\right)lcm\left(a,b\right)gcd\left(a,b\right)=ab$</p>
<h5 id="证明：-1"><a href="#证明：-1" class="headerlink" title="证明："></a>证明：</h5><p>$$<br>gcd\left(a,b\right)为a,b所有相同质因子最小幂的乘积;<br>\<br>lcm\left(a,b\right)为a,b所有相同质因子最大幂的乘积;<br>\</p>
<p>\</p>
<p>\begin{aligned}<br>\<br>lcm\left(a,b\right)gcd\left(a,b\right)即为a,b所有相同质因子幂的乘积,所以lcm\left(a,b\right)gcd\left(a,b\right)=ab;<br>\end{aligned}<br>$$</p>
<p>$\left(4\right)gcd\left(n,n+1\right)=1$</p>
<h5 id="证明：-2"><a href="#证明：-2" class="headerlink" title="证明："></a>证明：</h5><h6 id="反证法：-1"><a href="#反证法：-1" class="headerlink" title="反证法："></a>反证法：</h6><p>$$<br>\begin{aligned}<br>\<br>&amp;假设n,n+1有相同的大于1的公因子m<br>\<br>&amp;n=mx,n+1=my;\left(x,y均为整数\right)<br>\<br>&amp;(n+1)-n=m(y-x);m(y-x)=1;<br>\<br>&amp;\because m大于0,y、x均为整数<br>\<br>&amp;\therefore m(y-x)<br>\<br>&amp;\therefore 假设不成立</p>
<p>\end{aligned}<br>$$</p>
<h4 id="6-更相减损法"><a href="#6-更相减损法" class="headerlink" title="6.更相减损法"></a>6.更相减损法</h4><p>（1）$gcd\left(a,b\right)=gcd\left(a,a-b\right)$</p>
<p>$$<br>设gcd\left(a,b\right)=m,a=mx,b=my,\left(x,y均为整数且a&gt;b\right);<br>\<br>则a-b=m\left(x-y\right);<br>\<br>\therefore m整除\left(a-b\right)<br>\<br>\therefore gcd\left(a,b\right)=gcd\left(a,a-b\right)<br>$$<br>（2）$gcd\left(2a,2b\right)=2\times gcd\left(a,b\right)$</p>
<p>（3）$gcd\left(2a,b\right)=gcd\left(a,b\right)$</p>
<h4 id="7-辗转相除法（欧几里得算法）"><a href="#7-辗转相除法（欧几里得算法）" class="headerlink" title="7.辗转相除法（欧几里得算法）"></a>7.辗转相除法（欧几里得算法）</h4><h5 id="先行知识"><a href="#先行知识" class="headerlink" title="先行知识:"></a>先行知识:</h5><p>​        正整数$a,b\left(a&gt;b\right)$ ，$a%b$可以表示为$a=kb+c$,那么$gcd\left(a,b\right)=gcd\left(b,a%b\right)$</p>
<h5 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a>算法过程：</h5><p>​        由$ gcd(a, b) = gcd(b, a%b),$令$ a ′ = b, b ′ = a%b$递归调用$ gcd(a ′ , b ′ )，$返回$gcd(a, b) = gcd(a’,b’)$</p>
<h5 id="递归边界："><a href="#递归边界：" class="headerlink" title="递归边界："></a>递归边界：</h5><p>​        若较小的数 $b = 0，$由性质$gcd(a, 0) = a，$得到当前的结果为 $a$</p>
<h5 id="正确性证明："><a href="#正确性证明：" class="headerlink" title="正确性证明："></a>正确性证明：</h5><p>​        对于取模运算有$a%b=a-\lfloor\frac{a}{b}\rfloor b$，那么设$gcd(a,b)=d$。</p>
<p>​        $d|a,d|b,$同理可知$d|(a%b)$,因此$gcd(a,b)=gcd(a,a%b)=gcd(b,a%b)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-裴蜀定理（贝祖定理）"><a href="#8-裴蜀定理（贝祖定理）" class="headerlink" title="8.裴蜀定理（贝祖定理）"></a>8.裴蜀定理（贝祖定理）</h4><h5 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h5><p>​    设 $a,b$是不全为零的整数，则存在整数$x,y$使得 $ax + by = gcd(a, b)$ .</p>
<h5 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h5><p>$a,b$互质的时候存在整数$x,y$使$ax+by=1$</p>
<h4 id="9-扩展欧几里得定理"><a href="#9-扩展欧几里得定理" class="headerlink" title="9.扩展欧几里得定理"></a>9.扩展欧几里得定理</h4><h5 id="内容：-1"><a href="#内容：-1" class="headerlink" title="内容："></a>内容：</h5><p>已知整数$a,b,$求方程$ax+by=gcd\left(a,b\right)$的一组解​</p>
<p>对于取模运算有$a%b=a-\lfloor\frac{a}{b}\rfloor b$</p>
<h4 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h4><h3 id="二、-期望"><a href="#二、-期望" class="headerlink" title="二、 期望 "></a>二、<a id="期望"> <a href="#%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">期望</a> </a></h3><p>1.$E\left(X\right)^2$(期望的平方),$E\left(X^2\right)$(平方的期望) </p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉定理与扩展欧拉定理</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="欧拉定理与扩展欧拉定理"><a href="#欧拉定理与扩展欧拉定理" class="headerlink" title="欧拉定理与扩展欧拉定理 "></a>欧拉定理与扩展欧拉定理 </h1><blockquote>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>​                                                                若$gcd(a,p)=1$，那么$a^{\varphi(p)}\equiv 1 \pmod p$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明与证明费马小定理类似，可以构造一个$\varphi(p)$模$p$的剩余系，然后因为$gcd(a,p)=1$，所以该剩余系乘$a$与原剩余系相同，化简可得$a^{\varphi(p)}\equiv 1\pmod p$(详细见费马小定理证明部分)</p>
<p>​                                                                                        <font color=#FF4F00>$P={p_1,p_2, \cdots ,p_{\varphi(p)}}$</font></p>
<p>​                                                                                    <font color=#FF4F00> $P={ap_1,ap_2,\cdots,ap_{\varphi(p)}}$</font></p>
<p>​                                                                <font color=#FF4F00>$p_1\times p_2\times \cdots \times p_{\varphi(p)}\equiv ap_1\times ap_2\times \cdots \times ap_{\varphi(p)} \pmod p$</font></p>
<p>​                                                                                        <font color=#FF4F00> $a^{\varphi(p)}\equiv 1\pmod p$</font></p>
<h2 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>$$<br>a^b\equiv\begin{cases}<br>a^b\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \pmod p \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  gcd(a,p)\not =1,b\lt \varphi(p)<br>\<br>a^{b\bmod \varphi(p)}\ \ \ \ \ \ \ \ \ \ \ \ \pmod p \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ gcd(a,p)=1<br>\<br>a^{b\bmod \varphi(p)+\varphi(p)}\ \ \ \ \ \pmod p\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ gcd(a,p)\not=1,b\ge \varphi(p)<br>\end{cases}<br>$$</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>(1)若$x\equiv y \pmod {m_1},x\equiv y\pmod {m_2}$则$x\equiv y \pmod{lcm(m_1,m_2)}$</p>
<p>(2)$\varphi(p^k)=p^k-p^{k-1}\ge k $($p$为质数)(<font color=#FF4F00>数学归纳法</font>)</p>
<p>(3)$\varphi(nm)=\varphi(n)\varphi(m)$(注：$gcd(m,n)=1$)</p>
<p>​    证明：$m,n$没有公因子，根据欧拉函数计算公式可以提出$n\prod\limits_{i=1}^a p_i^{k_i}\times m\prod\limits_{i=1}^b p_i^{k_i}$(其中$n$中$p$和$m$中$p$完全不一样)，然后可以看出                      显然是$\varphi(n)\times \varphi(m)$</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>(1)首先证明<font color=#FF4F00>$a^b\equiv a^{b\bmod \varphi(p)}$</font></p>
<p>​                                                                                    <font color=#FF4F00>$b\bmod \varphi(p)=b- \lfloor\frac{b}{\varphi(p)} \rfloor\varphi(p)$</font></p>
<p>​                                                                                    <font color=#FF4F00>设$b\bmod \varphi(p)=r,\lfloor\frac{b}{\varphi(p)} \rfloor=k$</font></p>
<p>​                                                                            <font color=#FF4F00>那么$a^b\equiv a^b=a^b\equiv a^{r+k\varphi(p)}\pmod p$</font></p>
<p>​                                                                                <font color=#FF4F00>化简得$a^b\equiv a^ra^{\left(\varphi(p)\right)^k}\pmod p$</font></p>
<p>​                                                        <font color=#FF4F00>$\because gcd(a,p)=1$根据欧拉定理内容可知$a^{\varphi(p)}\equiv1\pmod p$</font></p>
<p>​                                                                                        <font color=#FF4F00>$\therefore$ $a^b\equiv a^r1^k\pmod p$</font></p>
<p>​                                                                                        <font color=#FF4F00>$\therefore a^b\equiv a^r\pmod p$</font></p>
<p>​                                                                                <font color=#FF4F00>$\therefore a^b \equiv a^{b \bmod \varphi(p)} \pmod p$</font></p>
<p><font size=5>证毕！</font></p>
<p>(2)再证明<font color=#FF4F00>$a^b \equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p$</font></p>
<p>​                ①当$gcd(a,p)=1$时，该式可可化为$a^b\equiv a^{b\bmod \varphi(p)}\pmod p$,进而根据欧拉定理可化为$a^b\equiv a^{b\bmod \varphi(p)}1\pmod p$</p>
<p>​                    $a^b\equiv a^{b\bmod \varphi(p)}a^{\varphi(p)}\pmod p$,$a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p$</p>
<p>​                ②当$gcd(a,p)\not= 1$时，考虑将$p$进行质因数分解，分解成$p_1^{k_1},p_2^{k_2},\cdots,p_n^{k_n}$，根据引理(1)，只要证明对于每个$p_i^{k_i}$均有                            $a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod {p_i^{k_i}}$即可，以下为证明过程：</p>
<p>​        <font color=#FF4F00>若$gcd(a,p_i^{k_i})=1$，则因为$\varphi(p_i^{k_i})|\varphi(m)$，因此由引理(3)与(1)和①证明过程可得$a^b\equiv a^{b \bmod \varphi(p)+\varphi(p)}\pmod {p_i^{k_i}}$成立</font></p>
<p>​                            <font color=#FF4F00>若$gcd(a,p_i^{k_i})\not= 1$，则$a$一定是$p_i$的倍数，设$a=np_i$,根据引理(2)可得$b\ge \varphi(p)\ge \varphi(p_i^{k_i})\ge k_i$</font></p>
<p>​                            <font color=#FF4F00>因此$p_i^{k_i}$既是$a^{b\bmod \varphi(p)+\varphi(p)}$的因子也是$a^b$的因子，因此$a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\equiv0 \pmod {p_i^{k_i}}$</font></p>
<p>​                                                                        <font color=#FF4F00>综上，$a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p(b\ge\varphi(p))$</font></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>线性同余方程</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h1><blockquote>
<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><p>​                                                                        <font color=#FF4F00> $ax+by\equiv c \pmod b$</font></p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p><strong>定理 1</strong> ：方程$ax+by=c$ 与方程$ax+by\equiv c \pmod b$是等价的，有整数解的充要条件为$gcd(a,b)\mid c$。</p>
<p>根据定理 1，方程$ax+by=c$，我们可以先用扩展欧几里得算法求出一组解$x_0,y_0$，也就是$ax_0+by_0=gcd(a,b)$ ，然后两边同时除以$gcd(a,b)$，再乘$c$。然后就得到了方程$\dfrac{ax_0c}{gcd(a,b)}+\dfrac{by_0c}{gcd(a,b)}=c$，然后我们就找到了方程的一个解。</p>
<p><strong>定理 2</strong> ：若$gcd(a,b)=1$且$x_0,y_0$为方程 的一组解，则该方程的任意解可表示为:$x=x_0+bk,y=y_0-ak$(对任意整数$k$均成立) ,。</p>
<p>根据定理 2，可以求出方程的所有解。但在实际问题中，我们往往被要求求出一个最小整数解，也就是一个特解$x$此时$k=b/gcd(a,b),x=(x%k+k)%k$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span><span class="comment">//x,y传地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=ex_gcd(b, a % b, x, y);</span><br><span class="line">	<span class="keyword">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp - a / b * y;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span><span class="comment">//在可以直接输出x，y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d = exgcd(a, b, x, y);<span class="comment">//最大公约数</span></span><br><span class="line">	<span class="keyword">if</span> (c % d)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0为无解</span></span><br><span class="line">	<span class="keyword">int</span> k = c / d;</span><br><span class="line"> x=(x % b + b) % b;</span><br><span class="line">	x =(x * k) % b;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>费马小定理</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h1 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h1><blockquote>
<h2 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h2><p>​                                <font size=6 color="87CEFA">$a^{p-1}\equiv 1 \pmod p(p为质数)$</font></p>
<h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>​                                <font size=6 color="87CEFA">$a*a^{p-2}\equiv1\pmod p,$所以$a$的逆元为$a^{p-2}$</font></p>
<h2 id="引理："><a href="#引理：" class="headerlink" title="引理："></a>引理：</h2><p><font size=4>设$m$为1个整数且$m&gt;1$，$b$是1个整数$gcd(m,b)=1$</font></p>
<p><font size=4>那么模$m$的剩余系$m={a_1,a_2,a_3,\cdots,a_n}$等价于$m={b\cdot a_1,b\cdot a_2,b\cdot a_3,\cdots,b\cdot a_n}$</font></p>
<p><font size=4>$m={b\cdot a_1,b\cdot a_2,b\cdot a_3,b\cdot a_n}$也为模$m$的完全剩余系​</font></p>
<h2 id="同余式性质"><a href="#同余式性质" class="headerlink" title="同余式性质:"></a>同余式性质:</h2><p><font size=5>若$ac\equiv bc\pmod m (c\not=0),$则$a\equiv b\pmod {m/gcd(c,m)}$</p>
<h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><p><font size=5>构造质数p的完全剩余系(与p互质的数)</font></p>
<p>​                                                            <font size=5 color="87CEFA">$P={1,2,3,\cdots,p-1}$</font></p>
<p><font size=5>因为$gcd(a,p)=1$，由引理可知</font></p>
<p>​                                                        <font size=5 color="87CEFA"> $A={a,2a,3a,\cdots,(p-1)a}$</font></p>
<p><font size=5>也是p的一个完全剩余系</font></p>
<p>​                    <font size=5 color="87CEFA">$1\times2\times 3\times \dots \times(p-1)=a\times2a\times3a\times\dots(p-1)a\pmod p$</font></p>
<p><font size=5>即$(p-1)!\equiv(p-1)!\cdot a^{p-1}\pmod p$</font></p>
<p><font size=5>易知$gcd((p-1)!,p)=1$根据同余式性质两边可以同时约去$(p-1)!$</font></p>
<p>​                                                            <font size=6 color="87CEFA">$a^{p-1}\equiv1\pmod p$</font></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>逆元</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><blockquote>
<h2 id="逆元简介"><a href="#逆元简介" class="headerlink" title="逆元简介"></a>逆元简介</h2><p>如果一个线性同余方程$ax\equiv 1\pmod b$ ，则 称$x$为$a\bmod b$的逆元，记作$a^{-1}$。</p>
<h2 id="求逆元的几种方法"><a href="#求逆元的几种方法" class="headerlink" title="求逆元的几种方法"></a>求逆元的几种方法</h2><ol>
<li><p>$exgcd$</p>
</li>
<li><p>求解$gcd(a,b)=1$的情况，无需$b$为质数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, x, y);</span><br><span class="line">    ll k = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = k - (a / b) * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="2">
<li><p>费马小定理</p>
<ol start="2">
<li><p>根据：                                                              <font color=#FF7F50>$a^{p-1}\equiv 1\pmod p$</font></p>
<p>可得：                                                            <font color=#FF4F00>$a\cdot a^{p-2}\equiv 1\pmod p$</font></p>
<p>注：其中模数p必须为质数</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;inv = apow(a, p<span class="number">-2</span>, p);  </span><br><span class="line"></span><br><span class="line">&gt;<span class="function">ll <span class="title">apow</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   ll ans = <span class="number">1</span>, base = a;</span><br><span class="line">      <span class="keyword">while</span> (b)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">              ans = ans * base % m;</span><br><span class="line">          base = base * base % m;</span><br><span class="line">          b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> ans % m;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>




<ol start="3">
<li><p>线性求逆元</p>
<p>(1)  求$1,2,3,\cdots,n$中每个数对关于$p$的逆元(其中$p$为质数)</p>
</li>
</ol>
<p>首先，<font color=#FF4F00>$1^{-1}\equiv 1 \pmod p$</font></p>
<p>然后，设<font color=#FF4F00>$p=ki+j, j=p%i,k=\dfrac{p}{i}(j\lt i,1\lt i\lt p) $</font>其中$i$为所求数</p>
<p>之后得到<font color=#FF4F00>$ki+j\equiv 0 \pmod p$</font></p>
<p>两边同时乘$i^{-1},j^{-1}$得：</p>
<pre><code>                                                                         &lt;font color=#FF4F00&gt;$kj^&#123;-1&#125;+i^&#123;-1&#125;\equiv 0 \pmod p$&lt;/font&gt;</code></pre>
<p>​          移项化简：    </p>
<p>​                                                                                <font color=#FF4F00>$i^{-1}\equiv -kj^{-1} \pmod p$</font></p>
<p>​                                                                                <font color=#FF4F00>$i^{-1}\equiv -(\dfrac {p}{i})j^{-1}\pmod p$</font></p>
<p>​                                                                                <font color=#FF4F00>$i^{-1}\equiv -(\dfrac {p}{i})(p \bmod i)^{-1}$</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_work</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">       inv[i] = (p - p / i) * inv[p % i] % p;<span class="comment">//(p-p/i)是为了防止出现负数，这里成立是在同余p的意义下</span></span><br><span class="line">&gt;&#125;<span class="comment">//这个式子其实相当于移项化简第二步</span></span><br></pre></td></tr></table></figure>

<p>(2)求任意$n$个数的逆元</p>
<p>首先计算$n$个数的前缀积($a_1,a_2,\cdots,a_n$)，记为$s_i$，然后用快速幂或$exgcd$计算$s_n$的逆元，记为$t_n$.因为$t_n$是$s_n$的逆元,当乘上$a_n$就会和$a_n$的逆元抵消，得到$a_1\sim a_{n-1}$的积逆元，记为$t_{n-1}$,同理可求出其他的$t_i$，则$a_i$的逆元可表示为$s_{i-1}t_{i}$</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">int</span> a[MAXN], t[MAXN], inv[MAXN], s[MAXN], ans;<span class="comment">//a数组是原来的数，t数组存前缀逆元，inv求逆元，s存前缀积</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">//快速幂求逆元</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ans = <span class="number">1</span>, base = a;</span><br><span class="line">   <span class="keyword">while</span> (b)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">           ans = <span class="number">1l</span>l * ans * base % p;</span><br><span class="line">       base = <span class="number">1l</span>l * base * base % p;</span><br><span class="line">       b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans % p;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">   s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">       s[i] = <span class="number">1l</span>l * s[i - <span class="number">1</span>] * a[i] % p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   t[n] = qpow(s[n], p - <span class="number">2</span>);<span class="comment">//前n个数的逆元积直接用前n个数的积求</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">       t[i] = <span class="number">1l</span>l * a[i + <span class="number">1</span>] * t[i + <span class="number">1</span>] % p;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">       inv[i] = <span class="number">1l</span>l * t[i] * s[i - <span class="number">1</span>] % p;<span class="comment">//求逆元为前i个数的逆元积乘前i-1个数的积</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//int x = 1;</span></span><br><span class="line"> 	<span class="comment">//for (int i = n; i &gt;= 1; i--)</span></span><br><span class="line">   <span class="comment">//&#123;</span></span><br><span class="line">   <span class="comment">//   ans = (ans + 1ll * inv[i] * x % p) % p;</span></span><br><span class="line">   <span class="comment">//    x = 1ll * x * mod % p;</span></span><br><span class="line">   <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF] CF645E</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/CF645E/</url>
    <content><![CDATA[<h1 id="CF645E-题解"><a href="#CF645E-题解" class="headerlink" title="CF645E 题解"></a>CF645E 题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> 参考了$Liao$_$rl$  大佬的题解</p>
<p>$dp$ 题</p>
<p>先不考虑空集</p>
<ul>
<li>设 $dp[i]$ 表示到这个位置，不同子序列的个数</li>
<li>当该位置字母没有出现过时，相当于在之前答案的每个位置都加上了一个新的字符，因此答案翻了 $1$ 倍，但还有当前新字母没有统计到答案里，因此答案还要 $+1$ 。 每个  $dp$  转移方程有  $dp[i]=2\times dp[i - 1] + 1$ </li>
<li>若之前出现过就减去以前出现过的最靠近现在位置的字母的贡献，因为有一部分答案是之前已经统计过的，因此要减去重复的，且该字符已经出现过，不用再 $+1$。转移为 $dp[i] = 2\times dp[i - 1] - dp[last[k] - 1]$ ， $k$ 表示当前位置所选的字符</li>
<li>$dp$ 转移已经有了，我们思考如何才能让答案最大，因为 $dp$ 是单调上升的，而且对答案有影响的只有第二个转移减去的 $dp[last[k]-1]$ ，因此我们要让 $dp[last[k]-1]$ 最小，只要让该字符 $k$ 出现位置最早即可 </li>
<li>最后不要忘了加上空集的答案</li>
<li>时间复杂度为 $O(26N)$</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TNT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                f = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>);</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x * f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">            write(x / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last[<span class="number">30</span>], dp[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = read(), k = read(), m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++m;</span><br><span class="line">            <span class="keyword">if</span> (!last[ch - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                dp[m] = <span class="number">1l</span>l * (<span class="number">2l</span>l * dp[m - <span class="number">1</span>] % mod + <span class="number">1</span>) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[m] = <span class="number">1l</span>l * (<span class="number">2l</span>l * dp[m - <span class="number">1</span>] % mod - dp[last[ch - <span class="string">&#x27;a&#x27;</span>] - <span class="number">1</span>] + mod) % mod;</span><br><span class="line"></span><br><span class="line">            last[ch - <span class="string">&#x27;a&#x27;</span>] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> minpos = <span class="number">2e6</span> + <span class="number">5</span>, minletter = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">                <span class="keyword">if</span> (last[j] &lt; minpos)</span><br><span class="line">                    minletter = j, minpos = last[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> now = i + m;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!minpos)</span><br><span class="line">                dp[now] = <span class="number">1l</span>l * (<span class="number">2l</span>l * dp[now - <span class="number">1</span>] % mod + <span class="number">1</span>) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[now] = <span class="number">1l</span>l * (<span class="number">2l</span>l * dp[now - <span class="number">1</span>] % mod - dp[minpos - <span class="number">1</span>] + mod) % mod;</span><br><span class="line"></span><br><span class="line">            last[minletter] = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write((dp[n + m] + <span class="number">1</span> % mod + mod) % mod);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace TNT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TNT::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷] 古代猪文</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/P2480%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87/</url>
    <content><![CDATA[<h1 id="古代猪文"><a href="#古代猪文" class="headerlink" title="古代猪文"></a>古代猪文</h1><p><a href="https://www.luogu.com.cn/problem/P2480">题目链接</a></p>
<p><font size=7>题目其实就是求$g^{\sum\limits_{d|n}^n C^{d}_{n}}\pmod {999911659}$</font></p>
<p>这道题我感觉挺好的，数论知识的结合性很好</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看到这个式子首先想到将$\sum\limits_{d|n}^n C^d_n$卢卡斯定理求组合数暴力求解，然后快速幂求解，但看到数据范围<font size=5>$1\le n,g \le 10^9$,</font>，立马pass，不可做，然后我们考虑其他方法，我们知道给的模数是质数，然后想到扩展欧拉定理$a^b\equiv a^{b\bmod \varphi(p)}\pmod p$，其中，因为$p$是质数，因此$\varphi(p)=p-1$，到此，此式转化为$a^b\equiv a^{b\bmod {p-1}}\pmod p$,看到这里我们会发现该式子与上述所求式子很像，上述式子也可化为$g^{\sum\limits_{d|n}^n C^{d}_{n}\bmod 999911658}\pmod {999911659}$，之后可以直接求(<font color=#FF4F00>讨论区有人没用CRT也过了</font>)或者用CRT，将999911658分解质因数,CRT一求最小解，最后快速幂解决就可以了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">999911659</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, p[<span class="number">1100000</span>], c[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125;, a[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, base = x;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * base % p;</span><br><span class="line">        base = base * base % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> k = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = k - a / b * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sai</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!(n % i))</span><br><span class="line">        &#123;</span><br><span class="line">            p[++tot] = i;</span><br><span class="line">            <span class="keyword">if</span> (i * i != n)</span><br><span class="line">                p[++tot] = n / i;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[<span class="number">50001</span>], inv[<span class="number">50001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fac_inv</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p; i++)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % p;</span><br><span class="line">    inv[p - <span class="number">1</span>] = qpow(fac[p - <span class="number">1</span>], p - <span class="number">2</span>, p) % p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[m] * (inv[n] % p) * (inv[m - n] % p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n % p, m % p, p) * Lucas(n / p, m / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll m = p / c[i];</span><br><span class="line">        exgcd(m, c[i], x, y);</span><br><span class="line">        ll t = (x % c[i] + c[i]) % c[i];</span><br><span class="line">        ans = (ans + a[i] * m * t) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> g, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fac_inv(c[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">            a[i] = (a[i] + Lucas(p[j], n, c[i])) % c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qpow(g, CRT(), mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, g;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; g;</span><br><span class="line">    <span class="keyword">if</span> (!(g % mod))<span class="comment">//不要忘了特殊情况qwq</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sai(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; solve(g, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre_work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷] P3601 签到题</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/P3601%E7%AD%BE%E5%88%B0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="P3601-签到题"><a href="#P3601-签到题" class="headerlink" title="P3601 [签到题]"></a>P3601 [签到题]</h1><blockquote>
<p> 对于我来说题有一定思维含量<del>(当然某些大佬秒切)</del></p>
<p> 本题主要是对数据范围和所给式子的分析来完成此题</p>
</blockquote>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><blockquote>
<p> 1.线性筛/埃氏筛</p>
<p> 2.欧拉函数</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p> 对于式子$\sum\limits_{i=l}^r qiaodao(i) \bmod 666623333$(其中$qiaodao(i)$为$\le i$与$i$不互质的数的个数)</p>
<p> 我们可以将其转化为$(\sum\limits_{i=l}^r i -\sum\limits_{i=l}^r \varphi(i))  \bmod 666623333$</p>
<p> 通过观察数据范围$1\le l,r\le 10^{12},r-l \le 10^6$可以发现直接求是不行的</p>
<p> 因为$r$最大为$10^{12}$，而$\sqrt r=10^6$，所以我们只需要用筛法求出$10^6$以内的质数即可，然后对于每个质数,对它的倍数求一次欧拉函数即可</p>
<p> 对于大于$10^6$的质数,我们发现大于$10^6$的数，其大于$10^6$的质数最多出现一个且其指数不超过$1$，因此我们可以开$1$个$vis[]$数组，根据正整数唯一分解定理，在求欧拉函数过程中，对求分解，最后当$vis[]$不为1时，必定存在一个大质数，否则就不存在</p>
</blockquote>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><blockquote>
<p> 1.要开 $long long$</p>
<p> 2.求欧拉函数时要先除再乘,否则可能会爆$longlong$</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TNT</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">666623333</span>;</span><br><span class="line"></span><br><span class="line">     ll phi[MAXN], vis[MAXN];<span class="comment">//phi[]求欧拉函数,vis[]是为了判断一个数是否可以分解出大质数</span></span><br><span class="line">     <span class="keyword">int</span> prime[MAXN], tot;</span><br><span class="line">     <span class="keyword">bool</span> mindiv[MAXN];</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ES</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//欧拉筛质数</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (!mindiv[i])</span><br><span class="line">                  prime[++tot] = i;</span><br><span class="line">              <span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; prime[j] * i &lt;= n; j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  mindiv[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">if</span> (!(i % prime[j]))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          ll l, r;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r - l; i++)</span><br><span class="line">              vis[i] = phi[i] = i + l;</span><br><span class="line"></span><br><span class="line">          ES(<span class="built_in">sqrt</span>(r));</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= r; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> p = prime[i];<span class="comment">//对于每1个小于1e6的质数，对它的倍数求一次欧拉函数</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span> (re <span class="keyword">int</span> j = (p - l % p) % p; j &lt;= r - l; j += p)</span><br><span class="line">              &#123;</span><br><span class="line">                  phi[j] = phi[j] / p * (p - <span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">while</span> (!(vis[j] % p))<span class="comment">//同时使该数不还有该质因子</span></span><br><span class="line">                      vis[j] /= p;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r - l; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (vis[i] != <span class="number">1</span>)<span class="comment">//求是否有大质数</span></span><br><span class="line">                  phi[i] = phi[i] / vis[i] * (vis[i] - <span class="number">1</span>);</span><br><span class="line">              ans = <span class="number">1l</span>l * (ans + i + l - phi[i]) % mod;<span class="comment">//统计答案</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace TNT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     TNT::main();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[IOI] 邮局</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/P4767/</url>
    <content><![CDATA[<h1 id="题解-P4767"><a href="#题解-P4767" class="headerlink" title="[题解]  P4767"></a>[题解]  P4767</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>我们考虑对于 $n$ 个村庄之间只有 $1$ 个的邮局的情况下显然该邮局在中位数的位置是最优的 ， 因此我们可以设 $w[i][j]$ 表示从第 $i$ 个村庄到第 $j$ 个村庄之间设 $1$ 个邮局的最小距离和，设  $m = \frac{i+ j}{2}$  ，则 $w[i][j] = |    d[i\cdots j] - d[m]|$  </li>
<li>设 $dp[i][j]$ 表示 前 $i$ 个村庄建了 $j$  个邮局的最小距离和，则状态转移为 $dp[i][j] = \min\limits_{k\lt i}(dp[i][j],dp[k][j - 1] + w[k + 1][i])$  得出方程后我们可以拿到 $40$ 分<del>的好成绩</del>（同学亲测能拿 $50$ 吸氧能拿 $70$ ？？？） ， 因为时间复杂度为 $O(n ^ 2m)$</li>
<li>我们发现主要复杂度浪费在枚举 $k$ 上 ， 我们考虑优化，我们可以<del>打表</del>证明 $w[i][j]$ 满足四边形不等式</li>
<li>首先我们可以发现 $w[i][j + 1] \ge w[i + 1][j]$ 是显然的 ，对于 $w_{a,b+1},w_{a+1,b}$ ，它们的中位数是相等的，记中位数为 $d_{mid}$ 那么有 $w_{a,b+1} + w_{a+1,b}=2w_{a+1,b}+d_{b+1}-d_{mid}+d_{mid}-d_a$ </li>
<li>因为 $w_{a,b}$ 的中位数一定小于等于  $d_{mid}$ ，所以 $w_{a,b} \le w_{a+1,b}+d_{mid} -d_a$ 同理，因为$w_{a+1,b+1}$ 的中位数一定小于等于 $d_{mid}$ ，因此$w_{a+1,b+1} \le w_{a+1,b}+d_{b+1}-d_{mid}$ $\therefore w_{a,b}+w_{a+1,b+1} \le w_{a+1,b}+w_{a,b+1}$ </li>
<li>之后按照网上四边形不等式的证明 （后续部分的证明均在网上可以找到，在此不多叙述）就好了 ，之后就是推 $dp[i][j]$ 满足四边形不等式 ，因为 $w[i][j]$ 满足四边形，不等式且 $\forall a\le b \le c\le d$  ，$w[a][d] \ge w[b][c]$ 因此$dp[i][j]$ 也满足四边形不等式 ，此时我们设 $s[i][j]$ 为令 $dp[i][j] $ 取到最小值的 $k$ 值 ， 则 $s[i][j-1] \le s[i][j] \le s[i+1][j]$  ，因此 $dp[i][j]$ 状态转移时从$s[i][j-1],s[i+1][j]$ 找最优决策即可</li>
<li>时间复杂度为 $O(mn)$ ，$n$ 为村庄数，$m$ 为邮局数</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>因为转移到用到 $s[i+1][j]$ ，因此要倒序枚举</p>
</li>
<li><p>数组不要忘了初始化</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TNT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[MAXN], w[MAXN][MAXN], dp[MAXN][<span class="number">310</span>], s[MAXN][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = read(), p = read();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">            a[i] = read();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + <span class="number">1</span> + v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v; i++)</span><br><span class="line">            <span class="keyword">for</span> (re <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= v; j++)</span><br><span class="line">                w[i][j] = w[i][j - <span class="number">1</span>] + (a[j] - a[(i + j) / <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">            dp[i][<span class="number">1</span>] = w[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= p; j++)</span><br><span class="line">            <span class="keyword">for</span> (re <span class="keyword">int</span> i = v; i &gt;= j; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>,s[v + <span class="number">1</span>][j] = v;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (re <span class="keyword">int</span> k = s[i][j - <span class="number">1</span>]; k &lt;= s[i + <span class="number">1</span>][j]; k++)</span><br><span class="line">                    <span class="keyword">if</span> (dp[k][j - <span class="number">1</span>] + w[k + <span class="number">1</span>][i] &lt; dp[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[k][j - <span class="number">1</span>] + w[k + <span class="number">1</span>][i];</span><br><span class="line">                        s[i][j] = k;<span class="comment">//更新s</span></span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[v][p]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace TNT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TNT::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA] UVA 1521 GCD Gussing Game</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/UVA1521/</url>
    <content><![CDATA[<h1 id="题解-UVA1521-GCD-Gussing-Game"><a href="#题解-UVA1521-GCD-Gussing-Game" class="headerlink" title="[题解]UVA1521 GCD Gussing Game"></a>[题解]UVA1521 GCD Gussing Game</h1><blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>最优策略是什么 ？</p>
</li>
<li><p>为什么这样是最好的 ？ </p>
</li>
</ol>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>对于问题 $1$ ， 我们发现每次询问一个数字 $x$ ， 如果返回的 $gcd(x,p) = t (t &gt; 1)$ ， 那么问题规模就下降到了 $\lfloor{\frac {n}{t}} \rfloor$  ，相当于继续寻找 $t$ 在 $n$ 里的倍数， 这显然是比 $gcd(x,p) = 1$ 时更优</li>
<li>因此在 $n$ 比较大时，通过一次询问降低问题规模要比回答 $1$ 更优 ， 在 $n$ 比较小的时候我们可以通过自己推式子或打个程序得出结论发现不会比 $1$ 情况更坏</li>
<li>此时我们便将问题转化为如何使在猜测的数是 $1$  的情况下更优，即最少次数遍历 $n$ 以内所有质数</li>
<li>考虑两个质数 $a,b $  ， 若不存在 $a$ 使得 $ab \le n$ 则只能单独筛掉 $b$ ，反之可以一次筛掉两个 ，这道题便解决了</li>
<li>预处理复杂度为$O(n)$  ， 单次询问时间复杂度为 $O(m)$ （其中 $m$ 为 $[1,n]$ 中 质数个数）</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">namespace</span> TNT</span><br><span class="line">&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> prime[MAXN],tot;</span><br><span class="line">  <span class="keyword">bool</span> mindiv[MAXN + <span class="number">10</span>];</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">TNT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(re <span class="keyword">int</span> i = <span class="number">2</span> ;i &lt;= MAXN;++i)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(!mindiv[i])</span><br><span class="line">               prime[++tot] = i;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span>(re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; prime[j] * i &lt;= MAXN;++j)</span><br><span class="line">           &#123;</span><br><span class="line">               mindiv[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(!(i % prime[j]))</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       TNT();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> l = <span class="number">1</span>,r = tot;</span><br><span class="line">           <span class="keyword">while</span>(prime[r] &gt; n)</span><br><span class="line">               --r;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span>(prime[l] * prime[r] &lt;= n)</span><br><span class="line">                   ++ans,++l,--r;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   ++ans,--r;               </span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TNT::main();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考来源：<a href="https://www.luogu.com.cn/blog/STDquantum/solution-uva1521">$STDquantum$ 的博客</a></p>
<p>​                    <a href="https://www.doc88.com/p-7364584446751.html">杜宇飞大牛：NEERC 11-13 题目选讲</a></p>
<p>​                    </p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷] P4296 密码箱</title>
    <url>/2020/10/29/%E9%A2%98%E8%A7%A3/%E5%AF%86%E7%A0%81%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="P4296-密码箱"><a href="#P4296-密码箱" class="headerlink" title="P4296 密码箱"></a>P4296 密码箱</h1><p>题目可转化为$x^2\equiv 1 \pmod n$，</p>
<p>移项可得$x^2-1 \equiv 0\pmod n$</p>
<p>根据平方差公式可以得到$(x-1)(x+1)\equiv 0 \pmod n$</p>
<p>设正整数$k$，使得$(x-1)(x+1)=kn$</p>
<p>对$n$进行分解,$n= ab$</p>
<p>原式最终转化为$(x-1)(x+1)=kab$</p>
<p>则使原式成立条件即为$(a|(x+1) \bigvee b|(x-1))\bigwedge (a|(x-1)\bigvee b|(x+1))$</p>
<p>在枚举$x$的时候顺便枚举$a,b$</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>1.当$x=1$时是唯一无解情况</p>
<p>2.记住开$long long$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TNT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> b, n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st.insert(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= <span class="built_in">sqrt</span>(n); a++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(n % a))</span><br><span class="line">            &#123;</span><br><span class="line">                b = n / a;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (ll i = b + <span class="number">1</span>; i &lt;= n; i += b) <span class="comment">//4e9会爆int</span></span><br><span class="line">                    <span class="keyword">if</span> (!((i + <span class="number">1</span>) % a))</span><br><span class="line">                        st.insert(i);</span><br><span class="line">                <span class="keyword">for</span> (ll i = b - <span class="number">1</span>; i &lt;= n; i += b)</span><br><span class="line">                    <span class="keyword">if</span> (!((i - <span class="number">1</span>) % a))</span><br><span class="line">                        st.insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = st.begin(); i != st.end(); i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace TNT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TNT::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>分块学习笔记</title>
    <url>/2020/10/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<h1 id="分块学习笔记"><a href="#分块学习笔记" class="headerlink" title="分块学习笔记"></a>分块学习笔记</h1><p>分块思想：</p>
<p>​                    分块算法的思想是通过适当的划分，预处理一部分信息保存下来，用空间换取时间，达到时空平衡。</p>
<p>​                    基本操作是，将一段序列，分成一定数量的块，每一块有一个长度，表示一段区间。</p>
<p>​                    不完整的块暴力处理。</p>
<p>分块大纲：分块，找区间，进行处理</p>
<p>​                    1.判断区间是否在一个块里</p>
<p>​                    2.在一个块里直接暴力处理</p>
<p>​                    3.不在一个块里中间整体的块整体处理，左边右边的块暴力处理</p>
<p><font color=00BFF size=4><strong>以下点击题目直接跳转题目所在链接</strong></font></p>
<h2 id="分块入门9练："><a href="#分块入门9练：" class="headerlink" title="分块入门9练："></a><a href="%5Bhttps://loj.ac/problems/search?keyword=%E5%88%86%E5%9D%97%5D(https://loj.ac/problems/search?keyword=%E5%88%86%E5%9D%97)">分块入门9练</a>：</h2><h3 id="（-为了方便将数的大小称为权值，标记的大小称为贡献-）"><a href="#（-为了方便将数的大小称为权值，标记的大小称为贡献-）" class="headerlink" title="（  为了方便将数的大小称为权值，标记的大小称为贡献 ）"></a><em>（<font color=#FF7F>  为了方便将数的大小称为权值，标记的大小称为贡献 </font>）</em></h3><h3 id="1-区间加，查询区间某一个元素"><a href="#1-区间加，查询区间某一个元素" class="headerlink" title="1.区间加，查询区间某一个元素"></a>1.区间加，查询区间某一个元素</h3><p>区间加：不完整的块直接暴力修改权值，完整的块设一个lazy标记，将增加的权值存到lazy标记中，每次对整块修改都是O（1）修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,block;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ = <span class="number">250</span>;<span class="comment">//块的多少（n/block）</span></span><br><span class="line"></span><br><span class="line">ll w[MAXN], b[MAXN], lazy[block_ + <span class="number">1</span>];<span class="comment">//lazy数组大小只要开块大小足够</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y, ll z)</span><span class="comment">//注意处理的细节，取值范围不要弄错！！！！！！！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)<span class="comment">//处理左端点所在的不完整的块</span></span><br><span class="line">        w[i] += z;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])<span class="comment">//如果左右端点不在一个块里处理右端点所在的不完整的块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            w[i] += z;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)<span class="comment">//处理中间完整的区间</span></span><br><span class="line">        lazy[i] += z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            add(x, y, z);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; w[y] + lazy[b[y]] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//更改后的权值加上完整块标记的lazy标记的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-区间加，区间查询小于某数的元素个数"><a href="#2-区间加，区间查询小于某数的元素个数" class="headerlink" title="2.区间加，区间查询小于某数的元素个数"></a>2.区间加，区间查询小于某数的元素个数</h3><p>思路：我们先来思考只有询问操作的情况，不完整的块枚举统计即可；而要在每个整块内寻找小于一个值的元素数，于是我们不得不                    要求块内元素是有序的，这样就能使用二分法对块内查询，<font color=#7FF0>需要预处理时每块做一遍排序 </font>，复杂度$O(nlogn)$，每次查询在                    $\sqrt n$个块内二分，以及暴力$2\sqrt n$个元素，总复杂度$O(nlogn + n\sqrt n log\sqrt n)$</p>
<p>区间加：维护一个lazy标记，略有区别的地方在于，不完整的块修改后可能会使得该块内数字乱序，所以头尾两个不完整块需要重新                        排序。</p>
<p>区间查询：块外还是暴力，查询小于（z– lazy）的元素个数，块内用（z – lazy）作为二分的值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[MAXN], b[MAXN], lazy[block_];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[block_];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//将不完整的块压入向量重新排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v[x].clear();</span><br><span class="line">	<span class="keyword">int</span> l = (x - <span class="number">1</span>) * block + <span class="number">1</span>, r = min(x * block, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) v[x].push_back(w[i]);</span><br><span class="line">	sort(v[x].begin(), v[x].end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">		w[i] += z;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">			w[i] += z;</span><br><span class="line">        spread(b[y]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">		lazy[i] += z;</span><br><span class="line">	spread(b[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> big = z * z;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">		<span class="keyword">if</span> (w[i] + lazy[b[i]] &lt; big)</span><br><span class="line">			sum++;</span><br><span class="line">	<span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">			<span class="keyword">if</span> (w[i] + lazy[b[i]] &lt; big)</span><br><span class="line">				sum++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">		sum+=lower_bound(v[i].begin(), v[i].end(), big - lazy[i]) - v[i].begin();<span class="comment">//STL大法好，自带二分查找，查找第一个大于等于查找元素的下标（vector从0开始）</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">		b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">		v[b[i]].push_back(w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b[n]; i++)</span><br><span class="line">		sort(v[i].begin(), v[i].end());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		<span class="keyword">if</span> (!opt)</span><br><span class="line">			add(x, y, z);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; ans(x, y, z) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-区间加，区间查询小于某个值的前驱（即比该值小的最大元素）"><a href="#3-区间加，区间查询小于某个值的前驱（即比该值小的最大元素）" class="headerlink" title="3.区间加，区间查询小于某个值的前驱（即比该值小的最大元素）"></a>3.区间加，区间查询小于某个值的前驱（即比该值小的最大元素）</h3><p>思路与 <font size=4><strong>2.</strong></font> 差不多，只不过把二分稍做修改就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll block_ = <span class="number">320</span>;</span><br><span class="line"></span><br><span class="line">ll w[MAXN], b[MAXN], lazy[block_];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; v[block_];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(ll x)</span><span class="comment">//处理块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v[x].clear();<span class="comment">//先将这块清零</span></span><br><span class="line">    ll l = (x - <span class="number">1</span>) * block + <span class="number">1</span>, r = min(x * block, n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = l; i &lt;= r; i++)</span><br><span class="line">        v[x].push_back(w[i]);<span class="comment">//重新加入可能改变的权值</span></span><br><span class="line">    sort(v[x].begin(), v[x].end());<span class="comment">//重新排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">        w[i] += z;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span> (ll i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            w[i] += z;</span><br><span class="line">        spread(b[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">        lazy[i] += z;</span><br><span class="line">    spread(b[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ans</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum = <span class="number">-1e9</span>;<span class="comment">//设该数为一个负数，防止数据有负数导致锅了</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">        <span class="keyword">if</span> (w[i] + lazy[b[x]] &lt; z)</span><br><span class="line">            sum = max(sum, w[i] + lazy[b[x]]);</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">        <span class="keyword">for</span> (ll i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            <span class="keyword">if</span> (w[i] + lazy[b[y]] &lt; z)</span><br><span class="line">                sum = max(sum, w[i] + lazy[b[y]]);</span><br><span class="line">    <span class="keyword">for</span> (ll i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(v[i].begin(), v[i].end(), z - lazy[i]) - v[i].begin();</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum = max(sum, v[i][p - <span class="number">1</span>] + lazy[i]);<span class="comment">//注意细节存储位置为p-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">-1e9</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//没有更新即为不存在返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        v[b[i]].push_back(w[i]);<span class="comment">//将每块将权值加入vector中，预处理一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= b[n]; i++)</span><br><span class="line">        sort(v[i].begin(), v[i].end());<span class="comment">//将每块的权值排序</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            add(x, y, z);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans(x, y, z) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-区间加，区间求和"><a href="#4-区间加，区间求和" class="headerlink" title="4.区间加，区间求和"></a>4.区间加，区间求和</h4><p>思路：仍是一个lazy标记，不过设个sum数组，维护每块的和，预处理一下</p>
<p>区间加：不完整的块贡献直接加到权值上，sum也加上贡献，完整的块sum加的贡献为整块的贡献</p>
<p>区间求和：不完整的块权值直接累加到答案上，完整的块将sum数组的值累加到答案上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll block_ = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">ll n, block, lazy[block_], b[MAXN], w[MAXN], sum[block_];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] += z;</span><br><span class="line">        sum[b[i]] += z;<span class="comment">//区间加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            w[i] += z;</span><br><span class="line">            sum[b[i]] += z;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[i] += z;</span><br><span class="line">        sum[i] += z * block;<span class="comment">//区间加（与线段树相似）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">answer</span><span class="params">(ll x, ll y, ll z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll mod = z + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">        ans = (ans + w[i] + lazy[b[i]]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            ans = (ans + w[i] + lazy[b[i]]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">        ans = (ans + sum[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        sum[b[i]] += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            add(x, y, z);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; answer(x, y, z) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-区间开方，区间求和"><a href="#5-区间开方，区间求和" class="headerlink" title="5.区间开方，区间求和"></a>5.区间开方，区间求和</h4><p>区间开方：开方比较难，但该题是下取整，而一个数开过几次根以后就会变成0或1，不完整的块直接暴力，完整的块这些块经过几次                            操作以后就会都变成 0 / 1，于是我们采取一种分块优化的暴力做法，开一个flag标记，只要每个整块暴力开方后，记录                            一下元素是否都变成了 0 / 1，区间修改时跳过那些全为 0 / 1 的块即可。</p>
<p>区间求和：不完整的块ans直接加上w[i],整块一直是用sum数组，因此ans直接加上sum权值即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> block, flag[block_], sum[block_], w[MAXN], b[MAXN], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//整块修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag[x])<span class="comment">//如果该块标记不为0，则返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flag[x] = <span class="number">1</span>;<span class="comment">//先更改标记</span></span><br><span class="line">    sum[x] = <span class="number">0</span>;<span class="comment">//清零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (x - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= min(x * block, n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i] = <span class="built_in">sqrt</span>(w[i]);</span><br><span class="line">        sum[x] += w[i];</span><br><span class="line">        <span class="keyword">if</span> (w[i] &gt; <span class="number">1</span>)<span class="comment">//只要有一个不为0/1</span></span><br><span class="line">            flag[x] = <span class="number">0</span>;<span class="comment">//flag标记就为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[b[i]] -= w[i];</span><br><span class="line">        w[i] = <span class="built_in">sqrt</span>(w[i]);</span><br><span class="line">        sum[b[i]] += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[b[i]] -= w[i];</span><br><span class="line">            w[i] = <span class="built_in">sqrt</span>(w[i]);</span><br><span class="line">            sum[b[i]] += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">        spread(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">answer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">        ans += w[i];</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            ans += w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">        ans += sum[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        sum[b[i]] += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            add(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; answer(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-单点插入，单点查询"><a href="#6-单点插入，单点查询" class="headerlink" title="6.单点插入，单点查询"></a>6.单点插入，单点查询</h4><p> 单点插入：对于插入一个块内的元素不多时，可以直接暴力插入，将块内的元素往后移即可，但当插入一个块内的元素过多，大大                            大于$\sqrt n$时，块内暴力复杂度就不能保证了，这时就要重新分块，每$\sqrt n$次插入后，重新把数列平均分一下块，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">20</span>;<span class="comment">//注意大小，n个数据，n次插入要开双倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ =<span class="number">800</span>;<span class="comment">//与上同理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, block, w[MAXN], tot,T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[block_];<span class="comment">//向量维护</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span><span class="comment">//重新分块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size();j++)</span><br><span class="line">                w[++pos] = v[i][j];<span class="comment">//先将权值重新分配</span></span><br><span class="line">            v[i].clear();<span class="comment">//清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);<span class="comment">//重新分块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        v[(i<span class="number">-1</span>)/block+<span class="number">1</span>].push_back(w[i]);</span><br><span class="line">    tot=(n<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= v[i].size())<span class="comment">//寻找x在第几块</span></span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            v[i].insert(v[i].begin() + x - <span class="number">1</span>, z);<span class="comment">//单点插入注意插入位置是x的左边</span></span><br><span class="line">            <span class="keyword">if</span> (v[i].size() &gt;= <span class="number">2</span> * block)<span class="comment">//如果该块的大小大于2*block就要重新分块</span></span><br><span class="line">                build();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       x -= v[i].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)<span class="comment">//查询答案</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= v[i].size())</span><br><span class="line">            <span class="keyword">return</span> v[i][x - <span class="number">1</span>];</span><br><span class="line">        x -= v[i].size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    T=n;<span class="comment">//注意开个变量记录询问次数，我这里忘了结果就锅了QAQ</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    build();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            add(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans(y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-区间乘，区间加，单点查询"><a href="#7-区间乘，区间加，单点查询" class="headerlink" title="7. 区间乘，区间加，单点查询"></a>7. 区间乘，区间加，单点查询</h4><p>区间乘：设lazy1标记，全初始化为1</p>
<p>区间加：设lazy2标记</p>
<p>做法与 <font size=4><strong>1.</strong></font> 相似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ = <span class="number">350</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, block, lazy1[block_], b[MAXN], w[MAXN], lazy2[block_];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//整块处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (x - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= min(x* block, n); i++)</span><br><span class="line">        w[i] = (w[i] * lazy2[x] + lazy1[x]) % mod;<span class="comment">//乘法优先性，先乘后加</span></span><br><span class="line">    lazy1[x] = <span class="number">0</span>;</span><br><span class="line">    lazy2[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll opt, ll x, ll y, ll z)</span><span class="comment">//两个标记的优先级是乘法高,所以在乘的时候要将加标记也乘z，其他处理与上边的题类似</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spread(b[x]);<span class="comment">//先整块处理一下，然后下面暴力</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= min(b[x] * block, y); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            w[i] = (w[i] + z) % mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[i] = w[i] * z % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[x] != b[y])</span><br><span class="line">    &#123;</span><br><span class="line">        spread(b[y]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (b[y] - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!opt)</span><br><span class="line">                w[i] = (w[i] + z) % mod;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                w[i] = w[i] * z % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b[x] + <span class="number">1</span>; i &lt;= b[y] - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!opt)</span><br><span class="line">            lazy1[i] = (lazy1[i] + z) % mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lazy1[i] = lazy1[i] * z % mod;</span><br><span class="line">            lazy2[i] = lazy2[i] * z % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        b[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        lazy2[b[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (!opt || opt == <span class="number">1</span>)</span><br><span class="line">            add(opt, x, y, z);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (w[y] * lazy2[b[y]] + lazy1[b[y]]) % mod &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-区间修改，区间询问"><a href="#8-区间修改，区间询问" class="headerlink" title="8.区间修改，区间询问"></a>8.区间修改，区间询问</h4><p> 思路：模拟一些数据可以发现，询问后一整段都会被修改，几次询问后数列可能只剩下几段不同的区间了。维护每个分块是否只有                    一种权值，区间操作的时候，对于同权值的一个块就O(1)统计答案，否则暴力统计答案，并修改标记，不完整的块也暴力。设                    一个lazy标记，初始化为-1，存储区间修改时修改的权值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_=<span class="number">350</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],b[MAXN],lazy[block_],block,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//整块处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[x]==<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//如果整块相同lazy标记为-1就返回</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(x<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=min(x*block,n);i++)</span><br><span class="line">        a[i]=lazy[x];<span class="comment">//将同一块里的权值全都修改</span></span><br><span class="line">    lazy[x]=<span class="number">-1</span>;<span class="comment">//lazy标记初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    add(b[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=min(b[x]*block,y);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=z) a[i]=z;</span><br><span class="line">        <span class="keyword">else</span> sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b[x]!=b[y])</span><br><span class="line">    &#123;</span><br><span class="line">        add(b[y]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(b[y]<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=y;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=z) a[i]=z;</span><br><span class="line">            <span class="keyword">else</span> sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=b[x]+<span class="number">1</span>;i&lt;=b[y]<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[i]!=<span class="number">-1</span>)<span class="comment">//不为-1整块均为同一个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lazy[i]!=z) lazy[i]=z;<span class="comment">//不为z那么直接将标记修改</span></span><br><span class="line">            <span class="keyword">else</span> sum+=block;<span class="comment">//为z答案直接加上该块的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//为-1暴力枚举</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=(i<span class="number">-1</span>)*block+<span class="number">1</span>;j&lt;=i*block;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]!=z) a[j]=z;</span><br><span class="line">                <span class="keyword">else</span> sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            lazy[i]=z;<span class="comment">//最后修改标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lazy,<span class="number">-1</span>,<span class="keyword">sizeof</span>(lazy));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        b[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans(x,y,z)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-区间查询最小众数（双倍经验题：-洛谷P4168蒲公英-）"><a href="#9-区间查询最小众数（双倍经验题：-洛谷P4168蒲公英-）" class="headerlink" title="9.区间查询最小众数（双倍经验题：**洛谷P4168蒲公英**）"></a>9.区间查询最小众数（双倍经验题：<font size=4>**<a href="https://www.luogu.com.cn/problem/P4168">洛谷P4168蒲公英</a>**</font>）</h4><p><del>该题巨复杂（对我这种蒟蒻）</del></p>
<p><del>通过感性理解</del>，我们发现这个区间的众数不是橙色区间的众数就是蓝色区间出现的任意数。</p>
<p><img src="https://i.loli.net/2018/11/24/5bf912331b9c0.png" alt="img"></p>
<p>设橙色部分中任意出现过的数字为$x$，众数为$y$</p>
<p>若$x$原本的数量加上了在蓝色部分的数量仍然没有$y$原本的数量加上$y$在蓝色部分的数量之和大，那么它是不可能成为众数的。若该数        没出现视其在橙色部分的数量为0即可。若在蓝色部分没出现且本来就不是众数，就更不可能打过众数了。所以我们只需要考虑蓝色        部分出现过的数字并将它和橙色部分的众数作比较即可因为蓝色部分长度和小于两格的长度，所以每次询问最多只需要查两格这么        多，一下就省去了很多时间。理解了这一部分，你就已经会这道题的正解了，剩下的是有一些细节的代码实现</p>
<p>为了方便，我们需要预处理一个数组$f$和一个数组$s$，$f[i][j]$表示从第$i$个块到第$j$个块中的众数，$s[i][j]$表示在前$i$块中$b[j]$出现的次数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_ = <span class="number">350</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, block, w[MAXN], b[MAXN], a[MAXN], f[block_][block_], s[block_][MAXN], t[MAXN]; <span class="comment">// f[i][j]表示i~j块的众数,s[i][j]表示前i块中b[j]出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build_block</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//该段点所在的块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        b[i] = w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n);<span class="comment">//离散化，排序</span></span><br><span class="line">    <span class="keyword">int</span> sum = unique(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;<span class="comment">//去重返回第一个重复的位置，-b-1就是最后一个不同元素即为不同元素个数</span></span><br><span class="line">    <span class="keyword">int</span> cnt = (n - <span class="number">1</span>) / block + <span class="number">1</span>;<span class="comment">//块的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + sum, w[i]) - b; <span class="comment">//a存储的是w[i]在b中的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)<span class="comment">//预处理s</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (i - <span class="number">1</span>) * block + <span class="number">1</span>; j &lt;= min(i * block, n); j++)</span><br><span class="line">            s[i][a[j]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++)</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)<span class="comment">//预处理f</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= cnt; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> MAX = f[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = (j - <span class="number">1</span>) * block + <span class="number">1</span>; k &lt;= min(j * block, n); k++)<span class="comment">//该数比MAX次数多或者比a[MAX]小</span></span><br><span class="line">                <span class="keyword">if</span> (s[j][MAX] - s[i - <span class="number">1</span>][MAX] &lt; s[j][a[k]] - s[i - <span class="number">1</span>][a[k]] ||</span><br><span class="line">                   (s[j][MAX] - s[i - <span class="number">1</span>][MAX] == s[j][a[k]] - s[i - <span class="number">1</span>][a[k]] &amp;&amp; a[k] &lt; MAX))</span><br><span class="line">                    	MAX = a[k];<span class="comment">//就更新</span></span><br><span class="line">            f[i][j] = MAX;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">int</span> bl = build_block(l);</span><br><span class="line">        <span class="keyword">int</span> br = build_block(r);</span><br><span class="line">        <span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (br - bl &lt;= <span class="number">1</span>)<span class="comment">//块差小于等于1直接暴力</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)<span class="comment">//通过桶来记录任意数出现次数</span></span><br><span class="line">                t[a[i]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                <span class="keyword">if</span> (t[a[i]] &gt; t[MAX] || (t[a[i]] == t[MAX] &amp;&amp; a[i] &lt; MAX))<span class="comment">////更新条件与上相同</span></span><br><span class="line">                    MAX = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)<span class="comment">//最后一定要记住把桶清空！！！！！！！！</span></span><br><span class="line">                t[a[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//大于1的处理方法</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= bl * block; i++)</span><br><span class="line">                t[a[i]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (br - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">                t[a[i]]++;</span><br><span class="line">            MAX = f[bl + <span class="number">1</span>][br - <span class="number">1</span>];<span class="comment">//中间完整块的众数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= bl * block; i++)<span class="comment">//从左块找</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pre = s[br - <span class="number">1</span>][MAX] - s[bl][MAX] + t[MAX];<span class="comment">//千万不要放在外面因为一直更新（因为这个一直锅）</span></span><br><span class="line">                <span class="keyword">int</span> now = s[br - <span class="number">1</span>][a[i]] - s[bl][a[i]] + t[a[i]];</span><br><span class="line">                <span class="keyword">if</span> (now &gt; pre || (now == pre &amp;&amp; a[i] &lt; MAX))<span class="comment">//更新条件与上相同</span></span><br><span class="line">                    MAX = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (br - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= r; i++)<span class="comment">//从右块找</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pre = s[br - <span class="number">1</span>][MAX] - s[bl][MAX] + t[MAX];</span><br><span class="line">                <span class="keyword">int</span> now = s[br - <span class="number">1</span>][a[i]] - s[bl][a[i]] + t[a[i]];</span><br><span class="line">                <span class="keyword">if</span> (now &gt; pre || (now == pre &amp;&amp; a[i] &lt; MAX))</span><br><span class="line">                    MAX = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= bl * block; i++)<span class="comment">//清空</span></span><br><span class="line">                t[a[i]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (br - <span class="number">1</span>) * block + <span class="number">1</span>; i &lt;= r; i++)<span class="comment">//清空</span></span><br><span class="line">                t[a[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b[MAX] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//答案存在b数组里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
